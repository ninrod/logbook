* Git tips and tricks

** general tips

-  find the git root:

#+BEGIN_SRC sh
    $ cd $(git rev-parse --show-toplevel)
#+END_SRC

-  find the most recent tag from HEAD

#+BEGIN_SRC sh
    $ git describe --abbrev=0 --tags
#+END_SRC

** git revision syntax

*** Viewing a file as it appears on Remotes, HEAD or INDEX

-  showing contents of a file as it appears in =HEAD= | =INDEX= ```sh #
   HEAD $ git show HEAD:path/to/file

* INDEX

$ git show :path/to/file

* REMOTE

$ git show origin/master:path/to/file ```

*** referencing a commit relative to a any git reference

-  you can reference a commit relative to a branch, HEAD, tag, etc...
-  see =$ man git-rev-parse=

#+BEGIN_SRC sh
    # specifying the leftmost father ancestor of a commit
    # these are equivalent: HEAD^ == HEAD^1 == HEAD~ == HEAD~1
    $ git show HEAD~

    # grandfather ancestor of head, always choosing the left most branch of ancestry
    # note that: HEAD^^ == HEAD~~ == HEAD~2
    $ git show HEAD~2

    # father ancestor of head, choosing the second branch of ancestry, left to right
    $ git show HEAD^2

    # father ancestor of head, choosing the third branch of ancestry, left to right
    $ git show HEAD^3
#+END_SRC

** Merges and Rebases

*** Rebase

-  =rebase= and =cherry-pick= equivalency (more info
   [[http://think-like-a-git.net/sections/rebase-from-the-ground-up/a-helpful-mnemonic-for-git-rebase-arguments.html][here]])

#+BEGIN_SRC sh
    # this snippet
    git checkout foo
    git checkout -b newbar
    git cherry-pick C D E
    git checkout bar
    git reset --hard newbar
    git branch -d newbar

    # is functionally equivalent to this snippet
    git rebase foo bar
#+END_SRC

*** verifying differences between local and upstream

-  more info on =$ man gitrevisions= around the line that contains:
   =:<n>:<path>=

#+BEGIN_SRC sh
    # common base:
    $ git show :1:package.json

    # 'ours'
    $ git show :2:package.json

    # 'theirs'
    $ git show :3:package.json
#+END_SRC

-  bonus: resolving conflicts with =--theirs= e =--ours=

#+BEGIN_SRC sh
    # method 01 'forcing theirs' (or :2: for ours)
    git show :3:package.json > package.json
    git add package.json

    # method 2
    $ git checkout --theirs _widget.html.erb
    $ git checkout --ours _widget.html.erb
#+END_SRC

*** reverting things

-  reverting a merge commit

   #+BEGIN_SRC sh
       $ git revert -m 1 <merge_commit_sha>
   #+END_SRC

-  Reverting last =n= commits:

#+BEGIN_SRC sh
    # say you have `A <- B <- C <- D` and want to create a commit that reverts commits B,C,D
    $ git reset --hard A

    # using a git-reflog reference: @{1} is, in fact, D
    $ git reset --soft @{1}

    $ git commit
#+END_SRC

-  change the pointer =HEAD= is pointing to

   #+BEGIN_SRC sh
       # observe variations: --soft, --mixed e --hard
       $ git reset 0d1d7fc32
   #+END_SRC

-  get your index and work tree into the desired state, without changing
   HEAD

   #+BEGIN_SRC sh
       $ git checkout 0d1d7fc32 .
   #+END_SRC

-  aborting a merge/rebase ```sh # merge $ git merge --abort

* rebase

$ git rebase --abort

* or yet

$ git reset HEAD --hard ```

** remove, delete files

-  remove all =untracked= files

#+BEGIN_SRC sh
    # verifying what will be removed
    $ git clean -f -n

    # remove all untracked files and dirs
    $ git clean -fd
#+END_SRC

-  remove all ignored files from the repo

#+BEGIN_SRC sh
    $ git ls-files -iX .gitignore| xargs -I{} git rm "{}"
#+END_SRC

-  show all untracked and gitignored files in the repo

#+BEGIN_SRC sh
    $ git ls-files -oiX .gitignore
#+END_SRC

-  show all staged (cached, or added to the index) files

#+BEGIN_SRC sh
    $ git diff --cached --name-only
#+END_SRC

** Branches

*** renaming a branch

-  If you want to rename a branch while currently at another branch:

#+BEGIN_SRC sh
    $ git branch -m <oldname> <newname>
#+END_SRC

-  If you want to rename the current branch:

#+BEGIN_SRC sh
    $ git branch -m <newname>
#+END_SRC

*** removing a branch locally and remotelly

-  locally: =git branch -D nome/do/branch=
-  remotelly: =git push origin --delete nome/do/branch (git 1.7+)=

*** remote branch checkout.

#+BEGIN_SRC sh
    # here 'remote_branch_name' doesn't exist locally and matches only one name on the remote: 
    $ git checkout remote_branch_name

    # alternative 
    $ git checkout -b localname origin/branchname

    # even more verbose alternative
    $ git branch --track experimental origin/experimental
    $ git checkout experimental
#+END_SRC

*** set up branch tracking

#+BEGIN_SRC sh
    # or --set-upstream
    $ git branch -u origin/master 

    # set tracking in a push statement
    $ git push -u origin master
#+END_SRC

-  showing what branch is tracking what remote:
   =git branch -vv (doubly verbose)=

#+BEGIN_SRC sh
    # -vv => doubly verbose
    $ git branch -vv
#+END_SRC

*** remove branch tracking (untrack, unset remote tracking branch)

-  just issue =git branch --unset-upstream= (since 1.8)
-  works since =git 1.8+=, Oct. 2012,
   [[https://github.com/git/git/commit/b84869ef14081b298a4ab825219221ccfcb2a3ba][commit
   b84869e]] by [[https://github.com/carlosmn][Carlos Martín Nieto
   (=carlosmn=)]]
-  relevant SO [[http://stackoverflow.com/a/3046478/4921402][question]]

*** verifying to what branches a commit is merged to

-  in other words, list all branches which commit\_sha is an ancestor of
-  more info
   [[http://stackoverflow.com/questions/18345157/how-can-i-tell-if-one-commit-is-an-ancestor-of-another-commit-or-vice-versa][here]]

#+BEGIN_SRC sh
    $ git branch --all --contains <commit_sha>
#+END_SRC

** git checkout

-  grabbing a specific file from another branch/commit/ref and add it to
   the index in current branch

#+BEGIN_SRC sh
    $ git checkout name_of_the_branch_or_commit_where_the_file_is -- path/to/the/file/you/want/to/grab
#+END_SRC

** git grep

*** searching the history for a pattern

-  using xargs

#+BEGIN_SRC sh
    $ git rev-list --all | xargs -I{} git grep '.bc' {}
    4a80d1ed1b9cd13b053498e87017890ad8fd72c5:a.txt:vou buscar pela string abc
    $
#+END_SRC

-  or, specifying a path

#+BEGIN_SRC sh
    $ git rev-list --all -- ./.vimrc | xargs -I{} git grep -e 'mapeia' {}
    9531cb5c99dfaec66d7275d5994cb29cf53da794:.vimrc:232:" por padrão o exchange.vim mapeia o X no visual mode
    744ce3fd47bc1cd69a6c79167ca7956f852de5be:.vimrc:232:" por padrão o exchange.vim mapeia o X no visual mode
    fe9958daf4a228b4779689fb9888555684a7ef52:.vimrc:235:" por padrão o exchange.vim mapeia o X no visual mode
    $
#+END_SRC

** git log tricks

*** grep trough commit messages

-  one pattern

#+BEGIN_SRC sh
    $ git log --grep=string_in_commit_msg
#+END_SRC

-  OR operation with various patterns

#+BEGIN_SRC sh
    $ git log --grep=string_in_commit_msg --grep=anotherpattern
#+END_SRC

-  AND operation with various patterns
-  more info [[http://gitster.livejournal.com/30195.html][on Julio C.
   Hamano's blog]]

#+BEGIN_SRC sh
    $ git log --all-match --grep='to' --grep='mapa' --grep='lu'
#+END_SRC

*** show only the master branch (only commits made to master)

#+BEGIN_SRC sh
    # if you are on master
    $ git log --first-parent

    # if you are not on master
    $ git log --first-parent master
#+END_SRC

*** show all commits reachable from current heads in your repo

-  and without using =--reflog=!

#+BEGIN_SRC sh
    $ gl $(git show-ref --heads -s | tr '\n' ' ') | head -n 20
#+END_SRC

*** git diff directly from git log

#+BEGIN_SRC sh
    # or -p
    $ git log --patch
#+END_SRC

*** don't use a pager, git, please. thanks

#+BEGIN_SRC sh
    $ git --no-pager --the-rest-of-your-command
#+END_SRC

*** show all developers names and emails for a particular project

#+BEGIN_SRC sh
    $ git shortlog -sne
#+END_SRC

*** filter logs by author name using mailmap

#+BEGIN_SRC sh
    $ gl --use-mailmap --author=DeveloperName
#+END_SRC

*** find when a file was deleted

-  more info [[http://stackoverflow.com/a/953573/4921402][here]],
   [[http://stackoverflow.com/a/7203551/4921402][here]]

#+BEGIN_SRC sh
    $ gl -- [file/path]
    $ gl -1 -- [file/path]

    # or even
    git log --all --full-history -- **/thefile.*

    # or
    $ gl --diff-filter=D --summary
    $ gco $commit~1 filename

    # or
    git checkout $(git rev-list -n 1 HEAD -- "$file")^ -- "$file"
#+END_SRC

*** trace the evolution of a range of lines

-  use the -L option:

#+BEGIN_SRC sh
    $ git log -L 33,+5:core-db2-up.sh
#+END_SRC

** git-ls-files

-  copying all gitignored and untracked files to another folder
   mantaining directory structure

   #+BEGIN_SRC sh
       $ git ls-files -oiX .gitignore | xargs -I{} rsync --relative "{}" ../git-ls-files-test-rsync
   #+END_SRC

-  copying all tracked and gitignored files to another folder mantaining
   directory structure

   #+BEGIN_SRC sh
       $ git ls-files -iX .gitignore | xargs -I{} rsync --relative "{}" ../git-ls-files-test-rsync
   #+END_SRC

   ** git-ls-tree

-  showing tracked files under the current directory

#+BEGIN_SRC sh
    $ git ls-tree --name-only HEAD .
#+END_SRC

** git-read-tree

-  read tree contents from any remote directly into index:

more info [[http://stackoverflow.com/a/5293270/4921402][here]]

#+BEGIN_SRC sh
    $ git read-tree remote/branch
    $ git checkout .
    $ git clean -fd
    $ git commit -m 'message'
#+END_SRC

** git push tricks

*** sync all

-  here suppose you have two remotes: one called github and other called
   origin.
-  the github remote has 137 branches and 370 tags.
-  the origin repo has only 1 branch, master, and it is already synced
   with master from github.
-  you want to push all branches and all tags from github to origin.
-  You only have to type this:

#+BEGIN_SRC sh
    $ git push --mirror
#+END_SRC

** git clone

*** get a shallow clone of a repo

#+BEGIN_SRC sh
    $ git clone --depth 1 repo
#+END_SRC

*** you can also /unshallow/ the clone

-  more info [[http://stackoverflow.com/a/6802238/4921402][here]]

#+BEGIN_SRC sh
    $ git fetch --unshallow
#+END_SRC

-  alternative: go deeper n commits down the history (e.g. 100 commits)

#+BEGIN_SRC sh
    $ git fetch --depth=100
#+END_SRC

*** Creating a remote that lives inside the file system

-  Say you have a git repo called =littlegitrepo=. You can create a
   remote that lives inside the file system with this line:
-  credits go to Michael Schwern's =Git for ages 4 and up=.

#+BEGIN_SRC sh
    # here remote will be a true remote
    $ git clone --bare littlegitrepo remote

    # you can clone from it (local) and do all sorts of stuff
    $ git clone remote local
    $ git clone remote local2
    $ cd local && git status
    $ vi a.txt
    $ git add a.txt
    $ git commit -m 'adding a.txt'
    $ git push
    $ cd ../local2
    $ git fetch
    $ git merge
#+END_SRC

** git tag

*** anotated tag

-  tag creation: =git tag -a [tagname] -m 'tag msg'=

*** automatically name a tag with =git describe=

#+BEGIN_SRC sh
    $ git tag -a "my-wonderful-tag-$(git describe --abbrev=7 --tags)" -m 'tag msg'
#+END_SRC

** Other useful commands

-  turn off git tracking for a specific file:
   =git update-index --skip-worktree Gruntfile.js=
-  turn on git tracking for a specific file:
   =git update-index --no-skip-worktree Gruntfile.js=

-  create a patch:
-  creating: =git format-patch master --stdout > my_new_patch.diff=
-  applying: =git am < my_new_patch.diff=
-  more info
   [[https://ariejan.net/2009/10/26/how-to-create-and-apply-a-patch-with-git/][here]]

-  export the working copy: =git archive master | tar -x -C /path=

-  git pretty format colors

   #+BEGIN_SRC sh
       git log --pretty=format:"%Credblah%Creset %Cgreenbluh%Creset %C(Yellow)lol%Creset %Cblueduh%Creset %C(magenta)lolmagenta%Creset %C(cyan)sdlkfjsdkfj%Creset %C(white)lollololzors%Creset"
   #+END_SRC

-  find all commits that changed a file:
   =git log --follow -p -- filename=

** Bizarre problems

*** submodules problems

-  updating a repo with submodules

#+BEGIN_SRC sh
    $ git fetch
    $ git rebase
    $ git submodule update --init --recursive
#+END_SRC

-  cloning and initing submodules

#+BEGIN_SRC sh
    $ git clone --recursive git://github.com/foo/bar.git
#+END_SRC

-  removing a submodule

#+BEGIN_SRC sh
    $ git rm --cached <submodule name>
    $ Delete the now untracked submodule files.
    $ Remove directory .git/modules/<submodule name>
    $ Delete the relevant lines from the .gitmodules file.
    $ Delete the relevant section from .git/config.
    $ add o .gitmodules no index
    $ git commit
#+END_SRC

*** beyond bizarre errors

-  fixing the terrible
   [[http://stackoverflow.com/questions/14700502/how-to-fix-git-zero-padded-file-modes-warning][=zero padded file modes=]]
   message:

#+BEGIN_SRC sh
    mkdir /newrepo
    cd /newrepo
    git init
    cd /oldrepo
    git fast-export --all | (cd /newrepo && git fast-import)
    git reset HEAD --hard at /newrepo
#+END_SRC

-  =bad time zone= fix (basically an export of the local files)

#+BEGIN_SRC sh
     git archive master | tar -x -C /somewhere/else
#+END_SRC

** interesting manual entries

-  =man gitrevisions(7)=

** Interesting links, tutorials, etc...

-  [[http://pcottle.github.io/learnGitBranching/?NODEMO][Learn Git
   Branching]]: excelent interactive tutorial (almost a game).
-  [[http://think-like-a-git.net][Think Like (a) Git]]: good guide site.
-  [[http://www-cs-students.stanford.edu/~blynn/gitmagic/][Git Magic]]:
   excelent html tutorial
-  [[http://stackoverflow.com/questions/4114095/revert-git-repo-to-a-previous-commit][Reversões
   de commits]]: stackoverflow question about how to revert commits.
-  [[https://www.youtube.com/watch?v=1ffBJ4sVUb4][Git For Ages 4 And
   Up]]: fantastic fun video introducing git. Highly recommended.
-  [[https://github.com/gitster][git mantainer github page]]
-  [[https://github.com/git-tips/tips][git tips]]

